package antixtransfer;

// node -> master initial connection message
message connect_init_node {
	required string ip_addr = 1;
  required string neighbour_port = 2;
  required string control_port = 3;
  required string gui_port = 4;
}

// client -> master initial connection message
message connect_init_client {
  required int32 num_robots = 1;
}

// master -> node/client response upon initial connect
message connect_init_response {
	required int32 id = 1;
	required double world_size = 2;
	required int32 sleep_time = 3;
  required double vision_range = 4;
	// only relevant for node
	optional int32 puck_amount = 5;

	// more... same as MasterServerClient/NodeInitialization?
}

message node_node_sync {
	required int32 id = 1;
}

message node_master_sync {
	required int32 my_id = 1;
	required int32 heard_id = 2;
}

// used to have synchronous turns
message node_master_done {
	required int32 my_id = 1;
}

// master -> node/client list of nodes
// XXX should probably rename this to reflect inclusion of Home
// "simulation state?"
message Node_list {
	message Node {
		required string ip_addr = 1;
    required string neighbour_port = 2;
    required string control_port = 3;
    required string gui_port = 4;
		required int32 id = 5;
		// optional as we only set this right before sending out node list
		optional double x_offset = 6;
	}

  message Home {
    required int32 team = 1;
    required double x = 2;
    required double y = 3;
  }

  // Indicates the robots for the given team are initially all on node with this
  // id
  message Robots_on_Node {
    required int32 team = 1;
    required int32 num_robots = 2;
    required int32 node = 3;
  }
	repeated Node node = 1;
  repeated Home home = 2;
  repeated Robots_on_Node robots_on_node = 3;
}

message connect {
	enum connectionType {
	     CLIENT = 0;
	     SERVER = 1;
	}

	required connectionType type = 1 [default = CLIENT];
}

message MasterServerClientInitialization {
	required double vision_range = 1;
	required double fov = 2;	
  required double world_size = 3;
  required double robot_radius = 4;
	required double home_radius = 5;
	// id assigned to the client
	required int32 id = 6;
	required int32 sleep_time = 7;
}	

message SendMap {
	message Robot {
		required int32 team = 1;
		required int32 id = 2;
		required double x = 3;
		required double y = 4;
	}

	message Puck {
		required double x = 1;
		required double y = 2;
		required bool held = 3;
	}

	repeated Robot robot = 1;
	repeated Puck puck = 2;
}

// GUI needs a bit more information
message SendMap_GUI {
	message Robot {
		required int32 team = 1;
		required int32 id = 2;
		required double x = 3;
		required double y = 4;
    required double a = 5;
	}

	message Puck {
		required double x = 1;
		required double y = 2;
		required bool held = 3;
	}

	repeated Robot robot = 1;
	repeated Puck puck = 2;
}

// potentially used for redesign
message SendMap2 {
	message Robot {
		required double x = 1;
		required double y = 2;
		optional int32 puck_id = 3;
		optional bool puck_action = 4;
	}
	repeated Robot robot = 1;
}

message move_bot {
  message Robot {
    required int32 id = 1;
    required int32 team = 2;
    required double x = 3;
    required double y = 4;
    required double a = 5;
    required double v = 6;
    required double w = 7;
    required bool has_puck = 8;
  }
  required bool from_right = 1;
  repeated Robot robot = 2;
}

message control_message {
	enum Type {
		SENSE = 1;
		SETSPEED = 2;
		PICKUP = 3;
		DROP = 4;
	}

	message Robot {
		required int32 id = 1;
		optional double v = 2;
		optional double w = 3;
	}

	// all robots in message with type TYPE get the action done to them

	required int32 team = 1;
	required Type type = 2;
	repeated Robot robot = 3;
}
